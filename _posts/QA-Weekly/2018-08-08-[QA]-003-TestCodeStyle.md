---
layout: post
title: "測試碼的特色"
categories: QA
tag: 
date: 2018-08-08 23:59:59 UTC+8 
last_modified_at: 2018-08-08 23:59:59 UTC+8 
---

# 前言

測試碼 ( Test Code ) 與產品碼 ( Product Code ) 因為各自所著重的價值不同，在撰寫時所應注重的原則也有所不同。

# 測試具備風險的產品碼

測試碼的價值來自於產品碼的風險控制，因此，應該針對「具備風險」的產品碼方法測試，部分幾乎不可能造成風險的程式碼，基本上不用特別撰寫對應測試碼。

## 單純的屬性值無需測試

對於公開的屬性，若是取得或設定的程序，包含任何邏輯，例如，延遲生成或是快取，則可能需要加以測試，若該公開屬性，僅是單純回傳或設定內部參數值，則無需特別測試。

## 私有函式無需測試

私有函式無需特別測試，因為私有函式應該直接或間接提供公開函式服務，只要妥善測試公開函式就會測試到私有函式的邏輯，若是某個特定私有函式未直接或間接被公開函式呼叫，則該私函式應該刪除。

因此，應避免在產品碼中透過直接動態取得方法執行的撰寫方式，因為難以透過靜態方式確認特定方法是否被呼叫。

## 抽象類別無需測試

抽象類別無需測試，因此抽象類別無法獨立生成執行個體，抽象類別主要提供衍生類別對應的操作或共同的邏輯，因此抽象類別無需個別測試，只要其衍生類別有被逐一測試，則必然會執行抽象類別的邏輯，若是抽象類別內的操作沒有衍生類別呼叫使用，則表示該段程序沒有實質作用，應該被刪除。

## 缺少商業邏輯無需測試

測試的價值在於確認商業邏輯，避免錯誤發生的風險，個別類別的公開方法若是缺少商業邏輯，例如，提供資料庫存取操作，或是檔案讀寫的代理類別，主要的任務在於實做介面提供外部操作，此種類別的公開方法就無需測試，因為預設外部元件能穩定提供服務。

單元測試的階段應假設外部元件是穩定可靠，因為對外部元件的驗證應該在元件使用的評估階段進行，若是日後外部元件確有問題，應該另設測試計畫確認，因為外部元件往往不是服務單一系統，不同系統引用相同外部元件是可預期的，所以應就外部元件建立對應測試計畫。

# 獨體模式與靜態類別

獨體類別或靜態類別的單元測試撰寫，往往很容易相互干擾，造成單元測試結果的不穩定，為解決此一問題，最好的模式就是不寫單元測試。

要能夠不寫獨體類別與靜態類別的單元測試，首先應該將獨體模式或靜態類別所包含的商業邏輯獨立出來，如此一來獨體類別或靜態類別本身沒有處理商業邏輯，就不具備單元測試的價值，因此，獨體類別或靜態類別不需進行單元測試。

# 複製貼上

產品碼著重在同一商業邏輯應該透過同一處程式碼，在該商業邏輯異動時，只需異動一處程式碼，若是撰寫產品碼時，反覆複製同一段程式碼在不同處，則當商業邏輯異動時，將造成系統多處必須修改，容易漏改或改錯，在撰寫產品碼時 [DRY ( Don't repeat yourself )](https://zh.wikipedia.org/wiki/%E4%B8%80%E6%AC%A1%E4%B8%94%E4%BB%85%E4%B8%80%E6%AC%A1) 原則幾乎是最基本必須遵守的原則。

但是與產品碼不同，測試碼強調

* 個別測試之間應保持獨立，以利個別執行及除錯。
* 測試碼描述必須保持直觀，除了便於閱讀，亦是避免測試碼的邏輯造成干擾。
* 測試碼應採最低成本維護，避免耗費過多資源。

因此，相對於產品碼來說，測試碼的程式複製貼上的情形是可以被接受，甚至是必須的；不過也應該考慮，適當的重構測試碼是否有助於提昇前述要點的成效，適時進行重構。

## 範例

* 情境說明：
    
    假設需要 XDocument 物件作為測試之用。
    
    一般產品碼大概都會透過物件動態組成，後續可能再重構：

    ```csharp
        private XDocument GetDocument()
        {
            var objReturn = new XDocument();
            XNamespace objXSD = "http://www.w3.org/2001/XMLSchema";
            var objSchema = new XElement(objXSD + "schema",
                new XAttribute(XNamespace.Xmlns + "xsd", "http://www.w3.org/2001/XMLSchema"));
            var objImport = new XElement(objXSD + "import",
                new XAttribute("namespace", "ar"),
                new XAttribute("schemaLocation", "ar.xsd"));

            objSchema.Add(objImport);
            objReturn.Add(objSchema);
            return objReturn;
        }
    ```

    但在測試碼中應該這麼寫：
    ```csharp
        private XDocument GetDocument()
        {
            var objReturn = new XDocument();
            var sSource = 
                "<xsd:schema xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\">" +
                "   <xsd:import namespace=\"ar\" schemaLocation=\"ar.xsd\" />" +
                "</xsd:schema>";
            objReturn = XDocument.Parse(sSource);

            return objReturn;
        }
    ```
    
    因為在測試碼中應該注重的是更快理解，而非程式重用。
